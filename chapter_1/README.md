# MySQL的架构
MySQL的逻辑架构图主要如下:

![拓扑图](images/数据库架构.PNG)

由架构图可以得知，MySQL的架构主要由三层组成
* 最上层是很多应用都有的,主要是客户端/服务器的的C/S架构，这一层主要负责连接处理，授权认证，安全等.

* 第二层是MySQL的核心服务功能，这一层包括了查询解析，分析，优化，缓存一级所有的内置函数(例如，日期前，时间，数学和加密函数)，
所有的存储引擎的功能都在这一层实现:存储过程，触发器，试图等

* 第三层包含了存储引擎。存储引擎负责MySQL中数据的存储和提取。和GUN/Linux下的格字文件系统一样，每个存储引擎都有他的又是和劣势。
服务器通过API与存储引起进行通信。这些接口屏蔽了了不同的存储引擎之间的差异，是的这些差异对上层的查询过程是透明的。存储引擎的API包
含了几十个底层的函数，用于执行注入"开始一个事务"或者"根据注解提取一行记录"等操作。但是存储引擎不会去解析SQL，不同的存储引起之间
也不会互相通信。


## 连接管理与安全性


* 客户端的连接：每个客户端连会在服务器上用于一个线程，这个连接查询指挥在这个单独的线程中执行，该线程只能轮流的在某个CPU核心或者CPU中执行。
服务器负责缓存线程，因此不需要未每一个新建的的连接创建或者销毁线程。

* 连接安全性：当客户端连接到MySQL服务器上时，服务器需要对其进行认证。认证用户名，原始主机信息和密码。如果使用了安全套接字(SSL)
的方式连接，可以使用X.509证书认证。一旦客户端连接成功，服务器就会继续验证该客户端是否具有某个执行特定查询的权限。




## 优化与执行

MySQL会解析查询,并发创建内部数据结构(解析树),然后进行格字优化，包括重写查询，决定表的读写顺序，以及选择合适的索引等。
用户可以通过特殊的关键字提示优化器，影响他的决策过程。也可以请求优化器解释(explain)优化过程的的各个因素，使用户可以
知道服务器时如何进行优化决策的，并且提供一个参考基准，便于用户重构查询和schema，修改相关的配置，时用于尽可能的高效运行。

优化器不关心使用的时什么存储引擎，但是存储引擎对于优化查询是有影响的。优化器会请求存储引擎提供容量或者某个具体的操作
开销信息，以及表数据的统计信息等，


## 并发操作

同一时刻对相同的数据进行操作会出现数据的不一致问题，解决这个问题可以加锁，但是这种方式是不能处理并发处理的，
某一个时刻只能处理一个请求。


### 读写锁

可以通过实现一个有两种类型的锁组成的锁系统来解决问题。这两种锁通常可以被称为共享锁(shared lock)和排他锁(execusive lock),
也叫读锁(read lock)和写锁(write lock).读锁是共享的，是非阻塞的。多个客户在同一个时刻是可以同时读取同一个资源的，互相不干扰。
写锁则是排他的，一个写锁会阻塞其他的写锁和读锁

### 锁的粒度


* 表记锁

* 行级锁


## 事务

事务就需要使用到ACID，ACID测试通常需要更强的CPU处理能力，更大的内存很更多的磁盘的空间。

* A(actomicity)原子性

* C(consistency)一致性

* I(isolation)隔离性

* D(durability)持久性



## 隔离级别

SQL中定义了四种隔离级别，每一种隔离级别都规定了一个事务中所做的秀爱，那些在事务内和事务间是可见的，较低级别的隔离通过可以执行
更高得并发，系统得开销更低



* READ UNCOMMITTED(未提交读)

在该级别中，事务中的修改及时没有提交，对其他事务也是可见的。事务可以读取为提交的数据，这也被称为脏读(Dirty Read)。
这个级别可能会导致很多问题，一般的开发很少使用。



* READ COMMITED(提交读)

大多数的数据库系统的默认隔离级别都是这个级别(MySQL不是)。该级别的事务就从开始之前到所做的任何修改对其他的事务都是不可见的。。
这个级别也叫不可重复读(nonrepeatable read),因为两次都是中性统一的查询，可能会得到不一样的结果.



* REPEATABLE READ(可重复读)


该级别的事务可以解决脏读的问题。该级别保证了同一个事务中多次读取统一的记录的结果是一致的。但是理论上，可重复读隔离级别还是无
法解决另外一个欢度的问题。幻读就是当某个事务在读取某个方位内的记录时，灵位一个事务又在该范围内插入了新的记录，当之前的事务再次
读取该范围内的的会产生幻行。InnoDB和XtraDB是通过多版本并发控制(MVCC,Mutiversion Concurrency Control)来解决幻读的问题的。


* SERIALIZABLE(可串行化)

该级别的的事务是最该级别的事务，避免了前面说的幻读问题，它会在每行在读取的数据上加锁，所以可能导致大量的超时和
锁争用的问题。实际应用中很是使用该级别，只有在接收了数据的一致性和没有并发的情况才会使用。


我们可以使用SET SESSION TRASNACTION ISOLATION LEVEL READ COMMITED;设置当前绘画的隔离级别.


### 事务日志

事务日志可以帮助提高事务的的效率，使用事务日子，存储引擎在修改表的时候只需要修改器内存拷贝，在把该修改的行为记录到持久在硬盘的
事务日志中，而不是每次的修改都持久化到磁盘上。事务日志采用的是追加的方式,因此写日志的操作都是磁盘上一块区域内存的顺序的I/O，而不是
随机的I/O需要在磁盘的多个地方移动刺头，索引采用事务日志的方式相对来说要快得多。事务日志持久之后，内存被修改的数据在后台可以慢慢的
刷会到磁盘。


## MySQL中的事务

MySQL提供了两种事务型的存储引擎：InnoDB和NDB Cluster。另外有一下第三方的存储引擎的也持之事务，例如XtraDB和PBXT


### 字段提交(AUTOCOMMIT)
MySQL默认的自动提交模式，也就是说。如果不是现实的开始一个事务，则每个查询都被当做一个事务执行提交操作。在当前链接中，
可以通过设置AUTOCOMMIT便利来启动或者禁用自动提交模式:
我们可以使用SHOW VARIABLES LIKE 'AUTOCOMMIT';查看事务自动提交是否开启

![拓扑图](images/MySQL事务1.PNG)

我们可以使用 SET AUTOCOMMIT=1;开启事务自动提交，SET AUTOCOMMIT=0;关闭事务自动提交。当我们关闭了之后，索引的操作都在一个
事务当中，知道我们显示的COMMIT提交或者ROLLBACK回滚，该事务结束，同时又开始可另外一个新的事务。修改AUTOCOMMIT对于非事务型的
的数据库不会有任何的的影响。

### 在事务中混合使用存储引擎

在事务事务中混合使用了事务性和非事务型的表，正常的情况不会出现什么问题，但是如果真的要回滚，非事务的表变得无法撤销，这种情况将无法确定。


### 隐式和显示锁定

InnoDB采用的是两段锁定协议(two-phase locking protocol).在事务执行的过程中随时都可以执行锁定，锁只有在执行commit或者rollback才会
释放




## 多版本并发控制


MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都实现了多版本的（MVCC），其他的数据库，
例如Oragle，PostgreSQL等其他数据库系统都是实现了MVCC，每种数据库实现的额不尽相同。

MVCC的是行级锁的变种，它在很多情况下避免了加锁的操作，开销更低.它是通过保存数据在某个时间点的快照来实现的。也就是说，
不管执行多长时间，每个是事务看到的数据都是一致的。

在InnoDB的MVCC中，是通过在每行记录后保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间(或者是删除时间)。
其实这个记录的不是具体的时间值，而是系统的版本号，每开始一个新的事务，系统的版本号就会自动增长。事务开始时刻的系统版本号会作为事务
的版本号，用来查询到的没行记录到的版本号进行比较。

SELECT 
    InnoDB会根据以下两个条件检查没行的记录:
        a. InnoDB只查找版本早于当前事务版本的数据行(也就是，行的系统版本号小于或者等于事务的系统版本号)，这样可以确保事务读取的行，
        要么是下事务的开始前已经存在的，要么是事务自身插入或者修改过的。
        
        b. 行的删除版本要么未定义，要么大于当前事务版本号.这可以确保事务读取到的行，在事务开始前违背删除.
        
    只有符合上述的两个天花的户口也们才能返回系统版本号作为行版本号. 

INSERT  
    InnoDB未插入的没一行保存当前系统的的版本号作为行版本号
DELETE
    InnoDB 为删除的没一行保存当前系统的版本号作为行删除标识
UPDATE
    InnoDB为插入的一哈给新记录，保存当前系统的版本号做为行版本号，同时保存当前系统的版本到原来的行作为行删除标识.
    

保存这个两个额外的版本号，是大多数读操作都可以不需要加锁。这设计使得读数据操作很简单，性能也很好，并且也能够保证只会读取到符合标准的行
不足之处是没行的记录都是需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作.

**注意**

MVCC只支持REPEATABLE READ和READ COMMITED两个隔离级别的工作。其他的两个隔离级别都是和MVCC不兼容的，因为READ UNCOMMITED总干事读取最新的行数据，
而不符合当前事务版本的数据。而SERIALIZABLE则会多所以的读取的行都加锁.


























    
      

















 













































































