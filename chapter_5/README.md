# 创建高性能的索引



索引时存储引擎用于快速找到记录的一种数据结构。这是所有的基本功能，所以索引对于良好的性能非常的重要，
数据量越多越重要。但是，在实际生活当中，索引经常被误解或者错误使用，导致性能逐渐下降。索引优化时对
查询优化最有效的手段了。



## 索引基础

索引可以包含一个或者多个列的值。如果所有包含多个列，那么列的顺寻也十分重要，MySQL只能搞笑的使用所有的最左前缀列


### 索引的类型

MySQL中有很多种类型，可以为不同的 常见场景提供更好的性能。索引时存储引擎层而不是服务器实现的。所以不同的存储
引擎的索引时不一样的，也不是所有的存储引擎层都支持所有的索引类型。




* B-Tree索引

当人们谈论索引的时候，如果没有特备的说明类型，那么多半是B-Tree索引，它使用B-Tree数据结构来存储数据。大所属的MySQL引擎都支持这种
索引。Archive引擎是一个例外，5.1之前是不支持任何的索引，5.1才开始支持自增列的索引.


    B-Tree通常意味着索引的值都是按顺序存储的，并且每一个叶子页到根的距离相同，B-Tree索引能够加快访问的速度，因为存储引擎不在需要进行
    全表的扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存储了只想子节点的指针，存储引擎根据这些指针向下
    层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下一层的节点，这些指针实际上定义了子节点页中的值的上限和下限。最终存储
    引擎要么找到对应的值，要么记录不存在。 

    叶子节点比较特别，它的指针指向的是被索引的数据，而不是其他的节点页(不同的引擎指针类型不同)。在根节点和叶子节点可能存在多层节点页。
    这个和表的大小直接的关联。B-Tree索引列是顺序组织存储的，索引适合查找范围数据。
    
    
    
* 例子：

        CREATE TABLE People(
        last_name VARCHAR(50) NOT NULL,
        first_name VARCHAR(50) NOT NULL,
        dob DATE NOT NULL,
        gender ENUM('m','f') NOT NULL,
        KEY(last_name,first_name,dob)
        );

     索引对多个值进行排序的一句是CREATE TABLE语句中定义的索引时列的顺序。看一下最后两个条目，两个人的姓和名否一样，则根据出生日期来排序
    
    
    可以使用btree索引的查询类型，btree索引使用用于全键值、键值范围、或者键前缀查找，其中键前缀查找只适合用于根据最左前缀的查找。前面示例中创建的多列索引对如下类型的查询有效：
    
    A：全值匹配
    
    全值匹配指的是和索引中的所有列进行匹配，即可用于查找姓名和出生日期
    
    B：匹配最左前缀
    
    如：只查找姓，即只使用索引的第一列
    
    C：匹配列前缀
    
    也可以只匹配某一列值的开头部分，如：匹配以J开头的姓的人，这里也只是使用了索引的第一列，且是第一列的一部分
    
    D：匹配范围值
    
    如查找姓在allen和barrymore之间的人，这里也只使用了索引的第一列
    
    E：精确匹配某一列并范围匹配另外一列
    
    如查找所有姓为allen，并且名字字母是K开头的，即，第一列last_name精确匹配，第二列first_name范围匹配
    
    F：只访问索引的查询
    
    btree通常可以支持只访问索引的查询，即查询只需要访问索引，而无需访问数据行，即，这个就是覆盖索引的概念。需要访问的数据直接从索引中取得。
    


* B-Tree的限制


    1. 如果不是按照索引的最左列开始查找，则无法使用索引。

    2.不跳过索引中的列。
    
    3.如果索引中的列的范围查询，则其右边所有的列都无法使用所有优化查询。


### 哈希索引












































